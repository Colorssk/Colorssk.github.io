{"meta":{"title":"hexo+github(blog)","subtitle":null,"description":null,"author":"Colorssk","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"","slug":"闭包,匿名函数：","date":"2018-06-24T06:34:01.324Z","updated":"2018-06-23T14:59:48.194Z","comments":true,"path":"2018/06/24/闭包,匿名函数：/","link":"","permalink":"http://yoursite.com/2018/06/24/闭包,匿名函数：/","excerpt":"","text":"闭包是啥 栗子： 12345678910function a()&#123; var n = 0; this.inc = function () &#123; n++; console.log(n); &#125;;&#125;var c = new a();c.inc(); //控制台输出1c.inc(); //控制台输出2 有权访问另一个函数作用域内变量的函数都是闭包。这里 inc 函数访问了构造函数 a 里面的变量 n，所以形成了一个闭包。 闭包就是一个函数引用另外一个函数的变量 因为变量被引用着所以不会被回收，因此可以用来封装一个私有变量 一个function这是声明了而没有调用，则不会被内存回收机制所回收，因此不必要的闭包只会徒增消耗 总结：闭包就是： 函数内部内部可以访问全局变量，但是函数外部不能访问函数内部的局部变量（函数内部声明变量时一定要用var，如果就写bar=2,那么就属于全局变量） 想要外部调用函数内部局部变量就return把它抛出来，并且，外部做var baz = foo()；和var blat = foo()是不相关的引用， 匿名函数 (function(){代码})()就等于执行了一个函数，只不过它是匿名的而已。如果在这个匿名函数内部想再次调用这个函数，就需要调用constructor属性了（这是Object中定义的，JS的继承机制如同Java一样保证了了所有对象都继承Object类）。 ​ 匿名函数是指那些无需定义函数名的函数。匿名函数与 拉姆达表达式 表达式（相当于熟知的箭头函数）是一回事。唯一的不同——语法形式不同。Lambda 表达式更进一步。本质上，它们的作用都是：产生方法——内联方法，也就是说，省去函数定义，直接写函数体。 ​ ​ Lambda 表达式一般形式： (input parameters) =&gt; {statement;} 123456789var baz1 = function() &#123; `var foo = 10;var bar = 2;return foo * bar;&#125;;//这也是匿名函数，因为省去了申明，如：function baz2()&#123;&#125; ​ ​ 栗子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//以下两个栗子都是署名过的函数内嵌匿名函数① function Foo() &#123; var a = 123; this.a = 456; (function() &#123; alert(a); // 123 alert(this.a); // undefined &#125;)(); &#125;; var f = new Foo(); ② function Foo() &#123; var a = 123; this.a = 456; (function(_this) &#123; alert(a); // 123 alert(_this.a); // 456 &#125;)(this);//通过参数传递访问外层署名函数中的属性 &#125;; var f = new Foo(); 以上两个对比，说明： （1）匿名函数可以直接访问到外层署名函数（Foo）中的变量（使用关键字var定义的），但不能访问外层署名函数的属性（使用关键字this定义的）； （2）匿名函数中的this指向的是匿名函数对象的地址，它与外层署名函数（Foo）对象的this指向的地址不同； （3）匿名函数若要访问外层署名函数（Foo）中的属性，可以通过参数传递的方式实现。 1234567891011121314151617181920212223242526272829303132333435363738//比较署名函数内嵌匿名 和 匿名函数内嵌匿名的区别 ① function Foo() &#123; var a = 123; this.a = 456; (function(b) &#123;//这是实参 alert(a); // 123 alert(b); // 456 &#125;)(this.a);//这是形参 &#125;; var f = new Foo(); ② (function() &#123; var a = 123; this.a = 456; (function() &#123; alert(a); // 123 alert(this.a); // 456 &#125;)(); &#125;)(); 所以： （1） 匿名函数既可以直接访问外层匿名函数中的变量，又直接可以访问外层匿名函数中的属性，而匿名函数却不可以直接访问外层已命名函数中的属性； （2）以上两种方式可以实现相同的功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//当同级出现匿名函数和署名函数时① (function() &#123; var a = 123; this.a = 456; (function() &#123; alert(a); // 123 alert(this.a); // 456 this.b = 789; &#125;)(); (function() &#123; alert(this.b); // 789 &#125;)(); &#125;)(); (function() &#123; alert(this.a); // 456,看上面同级（执行上下文），匿名可以直接读取里面的变量 alert(this.b); // 789，读取上下文中匿名函数的变量然后又找内嵌的匿名函数的变量 &#125;)(); ② function Foo() &#123; var a = 123; this.a = 456; (function() &#123; alert(a); // 123 alert(this.a); // undefined,要想有用需要传递参数 this.b = 789; &#125;)(); (function() &#123; alert(this.b); // 789 &#125;)(); &#125;; var f = new Foo(); (function() &#123; alert(this.a); // undefined，在查看执行上下文的时候只能读取匿名函数的变量，不能读取署名函数的属性（this.a是署名函数Foo定义的属性） alert(this.b); // 789，只要是匿名函数中定义的，无论是否被嵌套都属于执行上下文，下面的匿名函数都可以引用到 （重要） &#125;)(); 下面的栗子说明当在{}中没有同名的局部变量的时候a,就相当于this.a 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 ① function Foo() &#123; (function() &#123; this.b = 789; &#125;)(); (function() &#123; alert(this.b); // 789 alert(b); // 789 var a = 0; alert(a); // 0 &#125;)(); &#125; var f = new Foo(); (function() &#123; alert(this.b); // 789 alert(b); // 789 &#125;)(); ② function Foo() &#123; (function() &#123; this.b = 789; &#125;)(); (function() &#123; alert(this.b); // 789 alert(b); //undefined var b = 0; alert(b); // 0 &#125;)(); &#125; var f = new Foo(); (function() &#123; alert(this.b); // 789 alert(b); // 789 &#125;)(); 总结： 匿名函数能够访问外层署名函数的变量（var a）,但是不能访问其属性(this.b)//原因，this指向不同，匿名函数相当与执行函数 匿名函数想要访问外层署名函数的属性（this.b）需要传递参数进入闭包 匿名函数位于一个执行的上下文，也就是说一个匿名函数可以访问同级匿名函数中的属性或变量，或者外层匿名函数的属性或变量，再或者其他被嵌套的匿名函数","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-06-23T04:56:02.082Z","updated":"2018-06-23T04:56:02.082Z","comments":true,"path":"2018/06/23/hello-world/","link":"","permalink":"http://yoursite.com/2018/06/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}